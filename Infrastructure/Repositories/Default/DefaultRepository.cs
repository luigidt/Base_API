using AutoMapper;
using AutoMapper.QueryableExtensions;
using Domain.Aggregates;
using Domain.Interfaces.Entities.Base;
using Domain.Interfaces.Repositories.Base;
using Domain.Interfaces.Tables;
using Infrastructure.Context;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace Infrastructure.Repositories.Default
{
    public class DefaultRepository<TTable, TGenericEntity> 
        where TTable : class, ITable
        where TGenericEntity : class, IEntity
    {
        protected readonly DefaultContext DbContext;
        protected readonly DbSet<TTable> DbSet;
        protected readonly IMapper Mapper;

        protected virtual IQueryable<TTable> QueryableEntity => DbSet.AsQueryable();

        public DefaultRepository(DefaultContext context, IMapper mapper)
        {
            DbContext = context;
            Mapper = mapper;
            DbSet = DbContext.Set<TTable>();
        }

        public async Task<List<TReturnDTO>> GetFullList<TReturnDTO, TFilter>(TFilter filter)
        {
            var query = BuildQuery(filter);

            var result = await query.ToListAsync();

            return Mapper.Map<List<TReturnDTO>>(result);
        }

        protected async Task<int> GetCountList<TFilter>(TFilter filter)
        {
            var query = BuildQuery(filter);

            return await query.CountAsync();
        }

        protected async Task<bool> GetExist<TFilter>(TFilter filter)
        {
            var query = BuildQuery(filter);

            return await query.AnyAsync();
        }

        protected async Task<TReturnDTO?> Get<TReturnDTO>(int id)
        {
            var query = QueryableEntity;

            var result = await query.Where(x => x.Id == id).FirstOrDefaultAsync();

            return Mapper.Map<TReturnDTO>(result);
        }

        public virtual async Task<AutoGeneratedValue> InsertData(TGenericEntity model)
        {
            TTable entity = Mapper.Map<TTable>(model);

            var entry = await DbSet.AddAsync(entity);

            return new AutoGeneratedValue(() =>
            {
                var primaryKey = entry.Metadata.FindPrimaryKey()?.Properties.FirstOrDefault();

                if (primaryKey != null)
                {
                    var propertyInfo = entry.Entity.GetType().GetProperty(primaryKey.Name);

                    if (propertyInfo != null)
                    {
                        var value = propertyInfo.GetValue(entry.Entity);

                        if (value == null)
                        {
                            throw new InvalidOperationException($"Value for property '{primaryKey.Name}' is null.");
                        }
                        else
                        {
                            return (int)Convert.ChangeType(value, typeof(int));
                        }
                    }
                    else
                    {
                        throw new InvalidOperationException($"Property '{primaryKey.Name}' not found on entity.");
                    }                  
                }
                throw new InvalidOperationException("Primary key not found.");
            });
        }

        //public virtual async Task Update(TDomain dominio)
        //{
        //    var tempEntity = await Buscar(dominio.Id);
        //    var entity = await ConverteDominioParaEntidade(dominio, tempEntity);

        //    DbContext.Entry(tempEntity).State = EntityState.Detached;
        //    DbSet.Update(entity);
        //}

        //public virtual async Task Delete(int id)
        //{
        //    var entity = await Buscar(id);
        //    DbSet.Remove(entity);
        //}

        public async Task<PagedResult<TReturnDTO>> GetPagedList<TReturnDTO, TFilter>(TFilter filter, int pageNumber = 1, int pageSize = 10)
        {
            var query = BuildQuery(filter);

            int totalItemCount = await query.CountAsync();

            var resut = await query
                .Skip((pageNumber - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            var items = Mapper.Map<List<TReturnDTO>>(resut);

            return new PagedResult<TReturnDTO>
            {
                Items = items,
                TotalItems = totalItemCount,
                PageNumber = pageNumber,
                PageSize = pageSize,
                TotalPages = (int)Math.Ceiling(totalItemCount / (double)pageSize)
            };
        }

        private IQueryable<TTable> BuildQuery<TFilter>(TFilter filter)
        {
            var parameter = Expression.Parameter(typeof(TTable), "x");
            Expression? body = null;

            foreach (var property in typeof(TFilter).GetProperties())
            {
                var value = property.GetValue(filter);
                if (value != null)
                {
                    // Comparação direta entre o valor do filtro e o campo correspondente de TTable
                    var propertyExpression = Expression.Property(parameter, property.Name);
                    var constant = Expression.Constant(value);

                    // Ajusta para 'Contains' caso seja string, ou 'Equal' caso contrário
                    Expression comparison;
                    if (property.PropertyType == typeof(string))
                    {
                        comparison = Expression.Call(propertyExpression, "Contains", null, constant);
                    }
                    else
                    {
                        comparison = Expression.Equal(propertyExpression, constant);
                    }

                    body = body == null ? comparison : Expression.AndAlso(body, comparison);
                }
            }

            var where = body == null ? x => true : Expression.Lambda<Func<TTable, bool>>(body, parameter);

            var query = QueryableEntity;

            if (filter != null)
            {
                query = query.Where(where);
            }

            return query;
        }
    }

    public class AutoGeneratedValue : IAutoGeneratedValue
    {
        private readonly Func<int> primaryKey;

        public AutoGeneratedValue(Func<int> primaryKeyFunc)
        {
            primaryKey = primaryKeyFunc;
        }

        public int Id => primaryKey?.Invoke() ?? 0;

        public override int GetHashCode()
        {
            return HashCode.Combine(primaryKey);
        }
    }
}
